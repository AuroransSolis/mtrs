use crate::Token;
use logos::Lexer;

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Instruction {
    Add,
    AddImmediate,
    AddImmediateUnsigned,
    AddUnsigned,
    And,
    AndImmediate,
    BranchOnEq,
    BranchOnGteZero,
    BranchOnGteZeroAndLink,
    BranchOnGtZero,
    BranchOnLteZero,
    BranchOnLtZero,
    BranchOnLtZeroAndLink,
    BranchOnNotEq,
    Divide,
    DivideUnsigned,
    FpAbsoluteValueDouble,
    FpAbsoluteValueSingle,
    FpAdditionDouble,
    FpAdditionSingle,
    FpCompareEqDouble,
    FpCompareEqSingle,
    FpCompareLteDouble,
    FpCompareLteSingle,
    FpConvertSingleToDouble,
    FpConvertIntegerToDouble,
    FpConvertDoubleToSingle,
    FpConvertIntegerToSingle,
    FpConvertDoubleToInteger,
    FpConvertSingleToInteger,
    FpDivideDouble,
    FpDivideSingle,
    FpLoadDouble,
    FpLoadSingle,
    FpMoveDouble,
    FpMoveSingle,
    FpNegateDouble,
    FpNegateSingle,
    FpStoreDouble,
    FpStoreSingle,
    FpSubtractDouble,
    FpSubtractSingle,
    Jump,
    JumpAndLink,
    JumpRegister,
    LoadByte,
    LoadImmediate,
    LoadUpperImmediate,
    LoadWord,
    Move,
    MoveFromC1,
    MoveFromHi,
    MoveFromLo,
    MoveToC1,
    Multiply,
    MultiplyUnsigned,
    NoOp,
    Or,
    OrImmediate,
    StoreByte,
    ShiftLeftLogical,
    ShiftLeftLogicalVariable,
    SetOnLt,
    SetOnLtImmediate,
    SetOnLtImmediateUnsigned,
    SetOnLtUnsigned,
    ShiftRightArithmetic,
    ShiftRightLogical,
    ShiftRightLogicalVariable,
    Subtract,
    SubtractUnsigned,
    StoreWord,
    Syscall,
    Xor,
    XorImmediate,
}

impl Instruction {
    pub fn lex(lex: &mut Lexer<Token>) -> Option<Instruction> {
        match lex.slice() {
            "add" => Some(Instruction::Add),
            "addi" => Some(Instruction::AddImmediate),
            "addiu" => Some(Instruction::AddImmediateUnsigned),
            "addu" => Some(Instruction::AddUnsigned),
            "and" => Some(Instruction::And),
            "andi" => Some(Instruction::AndImmediate),
            "beq" => Some(Instruction::BranchOnEq),
            "bgez" => Some(Instruction::BranchOnGteZero),
            "bgezal" => Some(Instruction::BranchOnGteZeroAndLink),
            "bgtz" => Some(Instruction::BranchOnGtZero),
            "blez" => Some(Instruction::BranchOnLteZero),
            "bltz" => Some(Instruction::BranchOnLtZero),
            "bltzal" => Some(Instruction::BranchOnLtZeroAndLink),
            "bne" => Some(Instruction::BranchOnNotEq),
            "div" => Some(Instruction::Divide),
            "divu" => Some(Instruction::DivideUnsigned),
            "abs.d" => Some(Instruction::FpAbsoluteValueDouble),
            "abs.s" => Some(Instruction::FpAbsoluteValueSingle),
            "add.d" => Some(Instruction::FpAdditionDouble),
            "add.s" => Some(Instruction::FpAdditionSingle),
            "c.eq.d" => Some(Instruction::FpCompareEqDouble),
            "c.eq.s" => Some(Instruction::FpCompareEqSingle),
            "c.le.d" => Some(Instruction::FpCompareLteDouble),
            "c.le.s" => Some(Instruction::FpCompareLteSingle),
            "cvt.d.s" => Some(Instruction::FpConvertSingleToDouble),
            "cvt.d.w" => Some(Instruction::FpConvertIntegerToDouble),
            "cvt.s.d" => Some(Instruction::FpConvertDoubleToSingle),
            "cvt.s.w" => Some(Instruction::FpConvertIntegerToSingle),
            "cvt.w.d" => Some(Instruction::FpConvertDoubleToInteger),
            "cvt.w.s" => Some(Instruction::FpConvertSingleToInteger),
            "div.d" => Some(Instruction::FpDivideDouble),
            "div.s" => Some(Instruction::FpDivideSingle),
            "l.d" | "ldc1" => Some(Instruction::FpLoadDouble),
            "l.s" | "lwc1" => Some(Instruction::FpLoadSingle),
            "mov.d" => Some(Instruction::FpMoveDouble),
            "mov.s" => Some(Instruction::FpMoveSingle),
            "neg.d" => Some(Instruction::FpNegateDouble),
            "neg.s" => Some(Instruction::FpNegateSingle),
            "s.d" | "sdc1" => Some(Instruction::FpStoreDouble),
            "s.s" | "swc1" => Some(Instruction::FpStoreSingle),
            "sub.d" => Some(Instruction::FpSubtractDouble),
            "sub.s" => Some(Instruction::FpSubtractSingle),
            "j" => Some(Instruction::Jump),
            "jal" => Some(Instruction::JumpAndLink),
            "jr" => Some(Instruction::JumpRegister),
            "lb" => Some(Instruction::LoadByte),
            "li" => Some(Instruction::LoadImmediate),
            "lui" => Some(Instruction::LoadUpperImmediate),
            "lw" => Some(Instruction::LoadWord),
            "move" => Some(Instruction::Move),
            "mfc1" => Some(Instruction::MoveFromC1),
            "mfhi" => Some(Instruction::MoveFromHi),
            "mflo" => Some(Instruction::MoveFromLo),
            "mtc1" => Some(Instruction::MoveToC1),
            "mult" => Some(Instruction::Multiply),
            "multu" => Some(Instruction::MultiplyUnsigned),
            "noop" => Some(Instruction::NoOp),
            "or" => Some(Instruction::Or),
            "ori" => Some(Instruction::OrImmediate),
            "sb" => Some(Instruction::StoreByte),
            "sll" => Some(Instruction::ShiftLeftLogical),
            "sllv" => Some(Instruction::ShiftLeftLogicalVariable),
            "slt" => Some(Instruction::SetOnLt),
            "slti" => Some(Instruction::SetOnLtImmediate),
            "sltiu" => Some(Instruction::SetOnLtImmediateUnsigned),
            "sltu" => Some(Instruction::SetOnLtUnsigned),
            "sra" => Some(Instruction::ShiftRightArithmetic),
            "srl" => Some(Instruction::ShiftRightLogical),
            "srlv" => Some(Instruction::ShiftRightLogicalVariable),
            "sub" => Some(Instruction::Subtract),
            "subu" => Some(Instruction::SubtractUnsigned),
            "sw" => Some(Instruction::StoreWord),
            "syscall" => Some(Instruction::Syscall),
            "xor" => Some(Instruction::Xor),
            "xori" => Some(Instruction::XorImmediate),
            _ => None
        }
    }
}
