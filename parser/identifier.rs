use crate::{instruction::Instruction, token::Token};
use logos::{Lexer, Logos};
use std::fmt::{self, Debug};

#[derive(Clone, PartialEq)]
pub enum Identifier {
    Instruction(Instruction),
    Label(String),
}

impl Identifier {
    pub fn lex(lex: &mut Lexer<Token>) -> Option<Identifier> {
        Instruction::lex(lex)
            .map(|instruction| Identifier::Instruction(instruction))
            .or_else(|| Some(Identifier::Label(lex.slice().to_string())))
    }
}

impl Debug for Identifier {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Identifier::Instruction(instruction) => write!(f, "{:?}", instruction),
            Identifier::Label(label) => write!(f, "{}", label),
        }
    }
}

#[test]
fn test_lex_identifier() {
    let tests = [
        "add",
        "addi",
        "addiu",
        "addu",
        "and",
        "andi",
        "beq",
        "bgez",
        "bgezal",
        "bgtz",
        "blez",
        "bltz",
        "bltzal",
        "bne",
        "div",
        "divu",
        "abs.d",
        "abs.s",
        "add.d",
        "add.s",
        "bc1f",
        "bc1t",
        "c.eq.d",
        "c.eq.s",
        "c.le.d",
        "c.le.s",
        "cvt.d.s",
        "cvt.d.w",
        "cvt.s.d",
        "cvt.s.w",
        "cvt.w.d",
        "cvt.w.s",
        "div.d",
        "div.s",
        "l.d",
        "ldc1",
        "l.s",
        "lwc1",
        "mov.d",
        "mov.s",
        "mul.d",
        "mul.s",
        "neg.d",
        "neg.s",
        "s.d",
        "sdc1",
        "s.s",
        "swc1",
        "sub.d",
        "sub.s",
        "j",
        "jal",
        "jr",
        "la",
        "lb",
        "lbu",
        "lh",
        "lhu",
        "li",
        "lui",
        "lw",
        "move",
        "mfc1",
        "mfhi",
        "mflo",
        "mtc1",
        "mult",
        "multu",
        "noop",
        "or",
        "ori",
        "sb",
        "sc",
        "sh",
        "sll",
        "sllv",
        "slt",
        "slti",
        "sltiu",
        "sltu",
        "sra",
        "srav",
        "srl",
        "srlv",
        "sub",
        "subu",
        "sw",
        "syscall",
        "xor",
        "xori",
        "Okay",
        "so",
        "I",
        "think",
        "that",
        "is",
        "all",
        "of",
        "the",
        "instructions",
    ];
    let results = [
        Token::Identifier(Identifier::Instruction(Instruction::Add)),
        Token::Identifier(Identifier::Instruction(Instruction::AddImmediate)),
        Token::Identifier(Identifier::Instruction(Instruction::AddImmediateUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::AddUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::And)),
        Token::Identifier(Identifier::Instruction(Instruction::AndImmediate)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnEq)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnGteZero)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnGteZeroAndLink)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnGtZero)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnLteZero)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnLtZero)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnLtZeroAndLink)),
        Token::Identifier(Identifier::Instruction(Instruction::BranchOnNotEq)),
        Token::Identifier(Identifier::Instruction(Instruction::Divide)),
        Token::Identifier(Identifier::Instruction(Instruction::DivideUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::FpAbsoluteValueDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpAbsoluteValueSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpAdditionDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpAdditionSingle)),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpBranchOnConditionFalse,
        )),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpBranchOnConditionTrue,
        )),
        Token::Identifier(Identifier::Instruction(Instruction::FpCompareEqDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpCompareEqSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpCompareLteDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpCompareLteSingle)),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpConvertSingleToDouble,
        )),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpConvertIntegerToDouble,
        )),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpConvertDoubleToSingle,
        )),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpConvertIntegerToSingle,
        )),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpConvertDoubleToInteger,
        )),
        Token::Identifier(Identifier::Instruction(
            Instruction::FpConvertSingleToInteger,
        )),
        Token::Identifier(Identifier::Instruction(Instruction::FpDivideDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpDivideSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpLoadDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpLoadDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpLoadSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpLoadSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpMoveDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpMoveSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpMultiplyDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpMultiplySingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpNegateDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpNegateSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpStoreDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpStoreDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpStoreSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpStoreSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::FpSubtractDouble)),
        Token::Identifier(Identifier::Instruction(Instruction::FpSubtractSingle)),
        Token::Identifier(Identifier::Instruction(Instruction::Jump)),
        Token::Identifier(Identifier::Instruction(Instruction::JumpAndLink)),
        Token::Identifier(Identifier::Instruction(Instruction::JumpRegister)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadAddress)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadByte)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadByteUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadHalfword)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadHalfwordUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadImmediate)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadUpperImmediate)),
        Token::Identifier(Identifier::Instruction(Instruction::LoadWord)),
        Token::Identifier(Identifier::Instruction(Instruction::Move)),
        Token::Identifier(Identifier::Instruction(Instruction::MoveFromC1)),
        Token::Identifier(Identifier::Instruction(Instruction::MoveFromHi)),
        Token::Identifier(Identifier::Instruction(Instruction::MoveFromLo)),
        Token::Identifier(Identifier::Instruction(Instruction::MoveToC1)),
        Token::Identifier(Identifier::Instruction(Instruction::Multiply)),
        Token::Identifier(Identifier::Instruction(Instruction::MultiplyUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::NoOp)),
        Token::Identifier(Identifier::Instruction(Instruction::Or)),
        Token::Identifier(Identifier::Instruction(Instruction::OrImmediate)),
        Token::Identifier(Identifier::Instruction(Instruction::StoreByte)),
        Token::Identifier(Identifier::Instruction(Instruction::StoreConditional)),
        Token::Identifier(Identifier::Instruction(Instruction::StoreHalfword)),
        Token::Identifier(Identifier::Instruction(Instruction::ShiftLeftLogical)),
        Token::Identifier(Identifier::Instruction(
            Instruction::ShiftLeftLogicalVariable,
        )),
        Token::Identifier(Identifier::Instruction(Instruction::SetOnLt)),
        Token::Identifier(Identifier::Instruction(Instruction::SetOnLtImmediate)),
        Token::Identifier(Identifier::Instruction(
            Instruction::SetOnLtImmediateUnsigned,
        )),
        Token::Identifier(Identifier::Instruction(Instruction::SetOnLtUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::ShiftRightArithmetic)),
        Token::Identifier(Identifier::Instruction(
            Instruction::ShiftRightArithmeticVariable,
        )),
        Token::Identifier(Identifier::Instruction(Instruction::ShiftRightLogical)),
        Token::Identifier(Identifier::Instruction(
            Instruction::ShiftRightLogicalVariable,
        )),
        Token::Identifier(Identifier::Instruction(Instruction::Subtract)),
        Token::Identifier(Identifier::Instruction(Instruction::SubtractUnsigned)),
        Token::Identifier(Identifier::Instruction(Instruction::StoreWord)),
        Token::Identifier(Identifier::Instruction(Instruction::Syscall)),
        Token::Identifier(Identifier::Instruction(Instruction::Xor)),
        Token::Identifier(Identifier::Instruction(Instruction::XorImmediate)),
        Token::Identifier(Identifier::Label("Okay".to_string())),
        Token::Identifier(Identifier::Label("so".to_string())),
        Token::Identifier(Identifier::Label("I".to_string())),
        Token::Identifier(Identifier::Label("think".to_string())),
        Token::Identifier(Identifier::Label("that".to_string())),
        Token::Identifier(Identifier::Label("is".to_string())),
        Token::Identifier(Identifier::Label("all".to_string())),
        Token::Identifier(Identifier::Label("of".to_string())),
        Token::Identifier(Identifier::Label("the".to_string())),
        Token::Identifier(Identifier::Label("instructions".to_string())),
    ];
    for (test, result) in tests.iter().copied().zip(results.iter().cloned()) {
        println!("testing: '{}'", test);
        assert_eq!(Token::lexer(test).next().unwrap(), result);
    }
    let test = r#"add
    addi
    addiu
    addu
    and
    andi
    beq
    bgez
    bgezal
    bgtz
    blez
    bltz
    bltzal
    bne
    div
    divu
    abs.d
    abs.s
    add.d
    add.s
    bc1f
    bc1t
    c.eq.d
    c.eq.s
    c.le.d
    c.le.s
    cvt.d.s
    cvt.d.w
    cvt.s.d
    cvt.s.w
    cvt.w.d
    cvt.w.s
    div.d
    div.s
    l.d
    ldc1
    l.s
    lwc1
    mov.d
    mov.s
    mul.d
    mul.s
    neg.d
    neg.s
    s.d
    sdc1
    s.s
    swc1
    sub.d
    sub.s
    j
    jal
    jr
    la
    lb
    lbu
    lh
    lhu
    li
    lui
    lw
    move
    mfc1
    mfhi
    mflo
    mtc1
    mult
    multu
    noop
    or
    ori
    sb
    sc
    sh
    sll
    sllv
    slt
    slti
    sltiu
    sltu
    sra
    srav
    srl
    srlv
    sub
    subu
    sw
    syscall
    xor
    xori
    Okay
    so
    I
    think
    that
    is
    all
    of
    the
    instructions"#;
    for (i, token) in Token::lexer(test).enumerate() {
        assert_eq!(token, results[i]);
    }
}
